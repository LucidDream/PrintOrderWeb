Consumable Client v 2.0.0.2
C interface

To create a C/C++ application with Consumable Client API calls, the following files are needed
in addition to the ConsumableClient.dll:

    ConsumableClient.h
    ConsumableClient.lib

Usage notes and limitations

The Consumable Ledger application must be running for the Consumable Client API to work. The
server must be enabled in the Consumable Ledger application by the button "Run Server".

The value returned by ld3s_open() is an opaque 64-bit context handle (uint64_t). Do not
reinterpret it as a pointer or modify it.

The recommended pattern is:
    * Call ld3s_open() once per process to obtain a context value.
    * Reuse this context for all subsequent API calls (including from multiple threads).
    * Call ld3s_close() once when the application shuts down, after all threads have
      finished using the API.
Do not call ld3s_close() while any thread may still be using the context.


Example

An example of the interaction between the API and a host application may look like this:


uint64_t api_context = ld3s_open(); /* Call it once on the application startup */

if (api_context == 0) {
        /* Process the error situation, the API can't be used */
        const char *err = ld3s_get_last_error(api_context);
        if (err != 0) {
                /* Log or print the error string here */
                ld3s_free(api_context, (void*)err); /* Must be freed */
        }
        return;
}

/* Somewhere else - using the API: */

/* To get a template for the new job: */
char* job_template_string = ld3s_new_job(api_context);
if (job_template_string != 0) {
        /* Assuming we have converted the job_template_string from
           utf8 string to JSON map/array structure 'job': */
        ld3s_free(api_context, job_template_string); /* job_template_string is not needed now */
        job["inventoryParameters"]["wallets"][0]["accounts"][0]["currentExpenditure"] = 0.1;
        /* And so on for other accounts */

        /* Then we convert the JSON 'job' structure back to utf8-encoded character string
           job_string - don't ask me how */

        /* And submit the job: */
        uint64_t job_handle = ld3s_submit_job(api_context, job_string);
        if (job_handle != 0) {
                /* Now we poll the job status repeatedly */
                /* We have declared 'job_status' as JSON structure */
                bool done = false;
                char *job_status_string = 0;
                while (!done) {
                        /* Get the job status */
                        job_status_string = ld3s_get_job_status(api_context, job_handle);
                        if (job_status_string == 0) {
                                /* No new status available yet, or the handle is exhausted */
                                continue;
                        }
                        /* Assume we've converted 'job_status_string' to JSON 'job_status' */
                        ld3s_free(api_context, job_status_string); /* no longer needed */

                        /* 'final' indicates that the handle is exhausted, NOT necessarily success */
                        done = job_status["final"];
                }

                /* After final == true, inspect the 'status' field */
                if (strcmp(job_status["status"], "ready") == 0) {
                        /* We can use the results */
                } else {
                        /* The job finished, but not successfully (e.g., "denied" or "error") */
                }
        } else {
            /* Submission failed; ld3s_get_last_error() may provide details */
            const char *err = ld3s_get_last_error(api_context);
            if (err != 0) {
                    /* Log or print the error string here */
                    ld3s_free(api_context, (void*)err);
            }
        }
}

/* At the very end - just before the application exit */
ld3s_close(api_context);


	C callable functions

C callable functions of the Consumable Client API are defined in the ConsumableClient.h file.
All function names of the Consumable Client API are prepended by `ld3s_' suffix to avoid
possible name conflicts.


The following functions are declared in the ConsumableClient.h:


bool ld3s_cancel_job( uint64_t context, uint64_t handle )
	This function cancels the current job initiated by the ld3s_new_job function. All
	information regarding the transactions and balances will be lost. This function
	should only be called if the main application can't wait for the job to be finished.
Arguments:
context - a value returned by the ld3s_open function.
handle - the job handle returned by ld3s_submit_job function.

Return value:
true if the cancel request was sent to the server, false otherwise.


void ld3s_close( uint64_t context )
	Closes the Consumable Client API. Must be called at the very end when it is certain
	that any interaction with the API won't be needed.
Arguments:
context - a value returned by the ld3s_open function.


void ld3s_free( uint64_t context, void *pointer )
	Frees the memory pointed to by the pointer argument.
	The memory must be previously allocated by one of the Consumable Client API
	functions that return dynamically allocated strings:
	    - ld3s_new_job()
	    - ld3s_get_job_status()
	    - ld3s_get_last_error()
Arguments:
context - a value returned by ld3s_open function.
pointer - a pointer returned by ld3s_new_job(), ld3s_get_job_status() or ld3s_get_last_error().


char *ld3s_get_job_status( uint64_t context, uint64_t handle )
	Polls the status of a job (function ld3s_submit_job).
Arguments:
context - a value returned by the ld3s_open function.
handle - the job handle obtained by the function ld3s_submit_job.

Return value:
A pointer to the null-terminated character string representing the job status in the JSON
format if such information is available, 0 otherwise. A non-null pointer stays valid until
it is freed by ld3s_free call or the function ld3s_close is called. The JSON structure
contains the following fields:


final - a boolean value indicating whether this is the last status for this job handle.
        If false, the status can be polled again. If true, the returned value is final and
        succeeding calls to this function will return 0 for this job handle.

        IMPORTANT: final == true does NOT necessarily mean that the job has succeeded; it
        only means that no more status updates will be produced for this handle.


status - a string value that may be one of the following:
"denied"   - the job was denied by the server as it was malformed or any internal error
             occurred on the server.
"flushed"  - the job was flushed manually on the server side.
"missing"  - there is no such job on the server.
"processing" - the job is under processing on the server.
"ready"    - the job has been processed and the results are available in this JSON
             structure under the `results' field.
"waiting"  - the job has been delivered to the server and waits for processing.


transactionSuccess - a boolean value which is only present when the status field is "ready".
true indicates that all transactions were successful, false means that at least one of them
failed.


const char *ld3s_get_last_error( uint64_t context )
	This function is intended to return the detailed description of the last error.
Argument:
context - a value returned by the ld3s_open function.


The next call of this function always returns "No error" if no new error occurred since
the last call.


Return value:
A pointer to the string containing the diagnostics message. It must be explicitly
converted to void * and passed to the function ld3s_free when not needed.


char *ld3s_new_job( uint64_t context )
	Creates a template of a new job.
Argument:
context - a value returned by the ld3s_open function.

Return value:
A pointer to a null-terminated string representing the job template in the JSON format on
success, 0 otherwise. A non-null pointer stays valid until it is freed by the ld3s_free
function call or the function ld3s_close is called.
The JSON structure contains the inventoryParameters field, which, in turn, has the field
`wallets' representing the array of wallets. Each item of this array has an `accounts' field
which is an array of accounts belonging to that wallet. To obtain a job structure, the main
application should add a `currentExpenditure' field to each account which the tokens must
be spent from. The value of the `currentExpenditure' field is generally a fractional number
indicating the number of tokens to be spent. Upon this modification, the structure must be
converted back into the JSON format character string and passed to ld3s_submit_job function.

Remarks:
The calling application is responsible for freeing the returned value through the ld3s_free
function.
This function doesn't allocate any other resources except for the string it returns. It
merely generates a unique job id name and copies the current inventory status.


uint64_t ld3s_open()
	This function initializes the Consumable Client API. It must be called before any
	other ld3s_* function is called.

Return value:
An unsigned 64 bit value. A nonzero value indicates successful initialization, 0 is returned
if an error occurs.


uint64_t ld3s_submit_job( uint64_t context, const char *job )
	Sends a job for the server for processing.
Arguments:
context - a value returned by ld3s_open function.
job - a null-terminated character string containing the job information in the JSON format.
      To prepare that string, call ld3s_new_job function first, then convert its returned
      value into the JSON structure, set up the expenditures as indicated in the
      ld3s_new_job function description and convert the structure back into a character
      string in the JSON format.

Return value:
On successful completion, a non-zero job handle, 0 on failure.


Python Interface

It is recommended to use the ctypes package in the Python code to call Consumable Client
API functions.

Assuming the name of the loaded library is _cclib, the following code is needed to define
the function arguments and return values (the ConsumableClient.dll is supposed to be in the
same directory as the Python application):

    from ctypes import *

    _cclib = CDLL('.\\ConsumableClient.dll')  # The path must be explicit
    _cclib.ld3s_open.restype = c_ulonglong

    _cclib.ld3s_new_job.argtypes = [c_ulonglong]
    _cclib.ld3s_new_job.restype = c_char_p

    _cclib.ld3s_submit_job.argtypes = (c_ulonglong, c_char_p)
    _cclib.ld3s_submit_job.restype = c_ulonglong

    _cclib.ld3s_get_job_status.argtypes = (c_ulonglong, c_ulonglong)
    _cclib.ld3s_get_job_status.restype = c_char_p

    _cclib.ld3s_cancel_job.argtypes = (c_ulonglong, c_ulonglong)
    _cclib.ld3s_cancel_job.restype = c_bool

    _cclib.ld3s_free.argtypes = (c_ulonglong, c_void_p)
    _cclib.ld3s_free.restype = None

    _cclib.ld3s_get_last_error.argtypes = (c_ulonglong,)
    _cclib.ld3s_get_last_error.restype = c_char_p

    _cclib.ld3s_close.argtypes = (c_ulonglong,)
    _cclib.ld3s_close.restype = None

For conversion between the data structure and its JSON representation, the Python json
package is needed:

    import json

The character strings passed to the _cclib functions and returned by them must be converted
from/to the Python strings using encode and decode functions with "utf-8" argument.


A simple example of the Python code calling the API functions might look like this:

    def main():
        # Initializing Consumable Client
        ctx = _cclib.ld3s_open()
        if ctx == 0:
            print("Failed to initialize Consumable Client")
            return

        # Trying to get a new job template
        utf8_tmpl = _cclib.ld3s_new_job(ctx)
        if utf8_tmpl is None:
            print("A new job template was not created")
        else:
            job = json.loads(utf8_tmpl.decode("utf-8"))
            _cclib.ld3s_free(ctx, utf8_tmpl)

            # For example, set the same expenditure for each account
            for wallet in job["inventoryParameters"]["wallets"]:
                for account in wallet["accounts"]:
                    account["currentExpenditure"] = 0.1

            # Trying to submit the job
            utf8_job = json.dumps(job).encode("utf-8")
            job_handle = _cclib.ld3s_submit_job(ctx, utf8_job)
            if job_handle == 0:
                print("The job was not submitted")
                err = _cclib.ld3s_get_last_error(ctx)
                if err:
                    print("Error:", err.decode("utf-8"))
                    _cclib.ld3s_free(ctx, err)
            else:
                # Poll the job status
                done = False
                status = None
                while not done:
                    utf8_status = _cclib.ld3s_get_job_status(ctx, job_handle)
                    if utf8_status is None:
                        # No update yet, or the handle is exhausted
                        continue
                    status = json.loads(utf8_status.decode("utf-8"))
                    _cclib.ld3s_free(ctx, utf8_status)
                    done = status["final"]

                # Analyze the job results
                if status is None or status["status"] != "ready":
                    print("The job was not processed successfully (status =", status.get("status"))
                else:
                    if status.get("transactionSuccess", False):
                        print("Printing is allowed")
                    else:
                        print("Some of the transactions failed")

        # Close the Consumable Client
        _cclib.ld3s_close(ctx)


	Function calls in Python
To be done

